# Generated by Selenium IDE
import os
import time

import pytest
from selenium import webdriver
from selenium.common.exceptions import NoSuchElementException
from selenium.webdriver.common.by import By
from selenium.webdriver.firefox.service import Service
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
from webdriver_manager.firefox import GeckoDriverManager

from core.environment.host import get_host_for_selenium_testing

# === Configuración del navegador ===


def initialize_driver():
    """
    Inicializa un driver de Firefox con configuración compatible con sistemas snap.
    UVLHUB usa exactamente esta estructura.
    """
    options = webdriver.FirefoxOptions()

    # Directorio temporal alternativo (evita problemas con permisos en snap)
    snap_tmp = os.path.expanduser("~/snap/firefox/common/tmp")
    os.makedirs(snap_tmp, exist_ok=True)
    os.environ["TMPDIR"] = snap_tmp

    service = Service(GeckoDriverManager().install())
    driver = webdriver.Firefox(service=service, options=options)
    driver.set_window_size(1920, 1080)
    return driver


def close_driver(driver):
    """Cierra el navegador."""
    driver.quit()


# === Aux ===
GLOBAL_DELAY = 0.5


# Velocidad de ejecución (segundos)
def delayTimes(times=1):
    time.sleep(GLOBAL_DELAY * times)


host = get_host_for_selenium_testing()

# === Tests de interfaz ===


@pytest.fixture(scope="module")
def driver():
    """
    Fixture que crea y cierra automáticamente el navegador antes y después de todos los tests del módulo.
    """
    d = initialize_driver()
    yield d
    close_driver(d)


def test_login(driver):
    """
    Flujo del test:
    1. Abrir la aplicación en http://localhost:5000/ (host)
    2. Hacer click en el botón de login
    3. Introducir credenciales y log in
    4. Comprobar que el usuario se ha loggeado
    """

    # 1. Abrir la aplicación
    driver.get(f"{host}/")
    # driver.set_window_size(1920, 1080)
    delayTimes()

    # 2. Hacer click en el botón de login
    driver.find_element(By.CSS_SELECTOR, ".nav-link:nth-child(1)").click()
    delayTimes()

    # 3. Introducir credenciales y log in
    driver.find_element(By.ID, "email").click()
    delayTimes()
    driver.find_element(By.ID, "email").send_keys("user1@example.com")
    delayTimes()
    driver.find_element(By.ID, "password").click()
    delayTimes()
    driver.find_element(By.ID, "password").send_keys("1234")
    delayTimes()
    driver.find_element(By.ID, "submit").click()
    delayTimes()

    # 4. Comprobar que el usuario se ha loggeado
    # Verificamos que aparezca el enlace de "Log out" en el sidebar
    WebDriverWait(driver, 5).until(
        expected_conditions.presence_of_element_located((By.XPATH, "//a[contains(@href, '/logout')]")), "Login success"
    )
    assert driver.find_element(By.XPATH, "//a[contains(@href, '/logout')]")
    delayTimes(3)


def test_open_own_dataset(driver):
    """
    Flujo del test: (Nos hemos loggeado previamente)
    1. Ir a la pestaña de Mis Datasets
    2. Hacer click en el primero de ellos
    """
    # 1. Ir a Mis datasets
    driver.find_element(By.XPATH, "//a[contains(@href, '/dataset/list')]").click()
    delayTimes()

    # 2. Comprobar si hay datasets
    rows = driver.find_elements(By.XPATH, "//table/tbody/tr")

    if len(rows) == 0:
        pytest.fail("El usuario no tiene datasets propios")

    # Click en el primer dataset
    # El primer enlace dentro de la primera fila suele ser el título del dataset
    try:
        rows[0].find_element(By.TAG_NAME, "a").click()
    except NoSuchElementException:
        pytest.fail("No se encontró enlace en el primer dataset")

    # 3. Asegurarse que el dataset se ha abierto y pertenece al usuario
    # Estrategia: Comparar nombre del navbar con nombre de "Uploaded by"

    # Navbar name
    navbar_name_element = driver.find_element(By.CSS_SELECTOR, ".nav-link.dropdown-toggle .text-dark")
    logged_in_name = navbar_name_element.text.strip()

    # Uploaded by name
    # Buscamos el elemento "Uploaded by" (al div col-md-4) y luego su valor hermano (col-md-8)
    uploaded_by_element = driver.find_element(
        By.XPATH, "//span[contains(text(), 'Uploaded by')]/../following-sibling::div/a"
    )
    uploaded_by_name = uploaded_by_element.text.strip()

    assert (
        logged_in_name == uploaded_by_name
    ), f"Dataset verification failed: Expected owner '{logged_in_name}', but found '{uploaded_by_name}'"
    delayTimes(3)


def test_post_comment(driver):
    """
    Flujo del test: (Estamos en la página del dataset)
    1. Hacemos click en el recuadro de comentario
    2. Introducimos comentario
    3. Posteamos el comentario
    4. Comprobamos que el comentario se ha posteado correctamente
    """

    # Check if user is logged in by looking for "Join the discussion"
    try:
        if driver.find_elements(By.XPATH, "//*[contains(text(), 'Join the discussion')]"):
            # Found the text that implies anonymous user
            raise AssertionError("El usuario no está loggeado")
    except Exception as e:
        # If it wasn't an assertion error, re-raise. If elements check passed (empty list), we are good.
        if "El usuario no está loggeado" in str(e):
            raise e

    # Get logged in user name for verification later
    navbar_name_element = driver.find_element(By.CSS_SELECTOR, ".nav-link.dropdown-toggle .text-dark")
    logged_in_name = navbar_name_element.text.strip()

    # 1. Click textarea
    comment_form = driver.find_element(By.ID, "comment-form")
    textarea = comment_form.find_element(By.ID, "comment-content")
    textarea.click()
    delayTimes()

    # 2. Introduce comment
    comment_content = f"Selenium comment {int(time.time())}"
    textarea.send_keys(comment_content)
    delayTimes()

    # 3. Post comment
    submit_btn = comment_form.find_element(By.CSS_SELECTOR, "button[type='submit']")
    submit_btn.click()
    delayTimes()

    # Wait for comment to appear (dynamic check)
    try:
        WebDriverWait(driver, 5).until(
            expected_conditions.text_to_be_present_in_element((By.ID, "comments-container"), comment_content)
        )
    except Exception:
        raise AssertionError("El comentario no ha sido posteado")
    delayTimes()

    # 4. Verify
    try:
        # Get the specific comment element
        xpath = (
            f"//div[contains(@class, 'comment-item') and "
            f".//div[contains(@class, 'comment-text') and text()='{comment_content}']]"
        )
        comment_item = driver.find_element(By.XPATH, xpath)
    except NoSuchElementException:
        raise AssertionError("El comentario no ha sido posteado (No se encuentra el elemento)")

    # Check Author
    # .comment-author class
    author_element = comment_item.find_element(By.CLASS_NAME, "comment-author")
    author_name = author_element.text.strip()

    # Normalize names for comparison (Surname, Name vs Name Surname)
    normalized_logged_in = sorted(logged_in_name.replace(",", "").split())
    normalized_author = sorted(author_name.split())

    if normalized_logged_in != normalized_author:
        raise AssertionError(
            f"ERROR: No coincide el nombre del usuario con el autor. "
            f"Expected: '{logged_in_name}', Found: '{author_name}'"
        )

    # Check Content
    content_element = comment_item.find_element(By.CLASS_NAME, "comment-text")
    actual_content = content_element.text.strip()

    if actual_content != comment_content:
        raise AssertionError(
            f"ERROR: El contenido del comentario es diferente. Expected: '{comment_content}', Found: '{actual_content}'"
        )

    print("Post comment test passed!")
    delayTimes(3)


def test_update_comment(driver):
    """
    Flujo del test: (Estamos en la página del dataset)
    1. Hacemos click en el botón de editar del
        último comentario posteado / comentario superior
    2. Introducimos el nuevo comentario
    3. Posteamos el nuevo comentario
    4. Comprobamos que el comentario se ha actualizado correctamente:
       - Contenido actualizado y "Edited: RelativeTime" => Correcto
       - Contenido actualizado sin "Edited: RelativeTime" => Error
       - Mismo contenido y "Edited: RelativeTime" => Error
       - Mismo contenido sin "Edited: RelativeTime" => Correcto
    """
    # 1. Hacemos click en el botón de editar
    comment_item = driver.find_element(By.CSS_SELECTOR, "#comments-container .comment-item:first-child")
    comment_id = comment_item.get_attribute("data-comment-id")
    original_content = comment_item.find_element(By.CLASS_NAME, "comment-text").text.strip()

    edit_btn = comment_item.find_element(By.CLASS_NAME, "btn-edit-comment")
    # Scroll por si acaso
    driver.execute_script("arguments[0].scrollIntoView(true);", edit_btn)
    delayTimes()
    driver.execute_script("arguments[0].click();", edit_btn)
    delayTimes()

    # 2. Introducimos el nuevo comentario
    textarea = driver.find_element(By.ID, f"edit-textarea-{comment_id}")
    textarea.clear()
    new_content = f"Updated content {int(time.time())}"
    textarea.send_keys(new_content)
    delayTimes()

    # 3. Posteamos el nuevo comentario
    save_btn = driver.find_element(By.CSS_SELECTOR, f"#edit-form-{comment_id} button.btn-primary")
    driver.execute_script("arguments[0].click();", save_btn)
    time.sleep(1)  # Espera extra para asegurar refresco
    delayTimes()

    # 4. Comprobamos actualización
    # Recuperamos el elemento de nuevo para evitar StaleElementReferenceException y ver datos actualizados
    comment_item = driver.find_element(By.CSS_SELECTOR, "#comments-container .comment-item:first-child")
    content_element = comment_item.find_element(By.CLASS_NAME, "comment-text")
    actual_content = content_element.text.strip()

    meta_element = comment_item.find_element(By.CLASS_NAME, "comment-meta")
    meta_text = meta_element.text
    has_edited_label = "Edited" in meta_text

    # Caso: Contenido actualizado sin "Edited: RelativeTime"
    if actual_content != original_content and not has_edited_label:
        raise AssertionError("Error: Contenido actualizado sin 'Edited: RelativeTime'")

    # Caso: Mismo contenido y "Edited: RelativeTime"
    if actual_content == original_content and has_edited_label:
        raise AssertionError("Error: Mismo contenido y 'Edited: RelativeTime' presente")

    print("Update comment test passed!")
    delayTimes(3)


def test_delete_comment(driver):
    """
    Flujo del test: (Estamos en la página del dataset)
    1. Hacemos click en el botón de eliminar del último comentario posteado / comentario superior
    2. Confirmamos la eliminación (alerta nativa)
    3. Comprobamos que el comentario ha sido eliminado
    """
    # 1. Hacemos click en el botón de eliminar
    comment_item = driver.find_element(By.CSS_SELECTOR, "#comments-container .comment-item:first-child")
    comment_id = comment_item.get_attribute("data-comment-id")

    delete_btn = comment_item.find_element(By.CLASS_NAME, "btn-delete-comment")
    driver.execute_script("arguments[0].click();", delete_btn)

    # 2. Confirmamos la eliminación en la alerta
    WebDriverWait(driver, 5).until(expected_conditions.alert_is_present())
    delayTimes()
    driver.switch_to.alert.accept()
    delayTimes()

    # 3. Comprobamos eliminación
    try:
        # Wait for comment to disappear using data attribute
        WebDriverWait(driver, 5).until(
            expected_conditions.invisibility_of_element_located((By.XPATH, f"//div[@data-comment-id='{comment_id}']"))
        )
    except Exception:
        raise AssertionError("El comentario no ha sido eliminado")

    delayTimes(3)
    print("Delete comment test passed!")
